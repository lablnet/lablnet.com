import { d as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML } from './astro_Ohu8eKR9.mjs';

const html = "<p>This project evolved through several iterations, each marked by specific enhancements and the introduction of new features. Below is a detailed account of these versions, highlighting the key concepts, changes, and technical implementations.</p>\n<h3 id=\"version-1-feb-1-2024---feb-2-2024\">Version 1 (Feb 1, 2024 - Feb 2, 2024)</h3>\n<details>\n<summary>Key concepts in Version 1</summary>\n<p>In the initial version, I developed a GitHub Action workflow designed to activate upon every push to the repository and each pull request. The primary objectives were to execute coverage and linter checks for a Rust project, capture these outputs, and automatically comment on the pull request with the results. This workflow was successfully implemented and rigorously tested within the repository. <sup><a href=\"https://github.com/yubrew/ac-outpost/blob/main/.github/workflows/pr-tasks.yml\">1</a></sup>.</p>\n</details>\n<h3 id=\"version-2-feb-4-2024---feb-10-2024\">Version 2 (Feb 4, 2024 - Feb 10, 2024)</h3>\n<details>\n<summary>Key Changes in Version 2</summary>\n<ul>\n<li>\n<p>Significant advancements were made in this iteration:</p>\n</li>\n<li>\n<p>A new GitHub Action workflow, <code>ai-comment.yml</code>, was created to operate on every push and pull request, enhancing our project’s automation and integration capabilities. <sup><a href=\"https://github.com/yubrew/ac-outpost/blob/main/.github/workflows/ai-audit.yml\">2</a></sup></p>\n</li>\n<li>\n<p>A key task was to aggregate all Rust files following a specified schema, excluding any that matched defined patterns (‘test’, ‘schema’). This was achieved through a straightforward shell script, which efficiently processed and prepared these files for further analysis.</p>\n<ul>\n<li>\n<p>Note: I am sharing these files because they are on a public repo.</p>\n</li>\n<li>\n<p>I’ve done this with a simple shell script below:</p>\n  <details>\n  <summary><strong>rust_file_aggregator.sh</strong></summary>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Initialize the file</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> rust.md</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Find all the Rust files in the current directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># and its subdirectories.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># and iterate over the files</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">find</span><span style=\"color:#9ECBFF\"> .</span><span style=\"color:#79B8FF\"> -name</span><span style=\"color:#9ECBFF\"> \"*.rs\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#F97583\"> while</span><span style=\"color:#79B8FF\"> read</span><span style=\"color:#9ECBFF\"> file</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Check if the file name matches the exclusion patterns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # ['test', 'schema']</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> [[ $file </span><span style=\"color:#F97583\">!=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">test</span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> $file </span><span style=\"color:#F97583\">!=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">schema</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> ]]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Print the file name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"Processing file: </span><span style=\"color:#E1E4E8\">$file</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Append the file name to the output file</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        echo</span><span style=\"color:#9ECBFF\"> \"### FILE: $(</span><span style=\"color:#B392F0\">basename</span><span style=\"color:#E1E4E8\"> $file</span><span style=\"color:#9ECBFF\">)\"</span><span style=\"color:#F97583\"> >></span><span style=\"color:#9ECBFF\"> rust.md</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Append the file content to the output file</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        cat</span><span style=\"color:#E1E4E8\"> $file </span><span style=\"color:#F97583\">>></span><span style=\"color:#9ECBFF\"> rust.md</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    fi</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span></code></pre>\n  </details>\n</li>\n<li>\n<p>These files were then transmitted to a mock API endpoint (Which I created), crafted using AWS Lambda and DynamoDB, demonstrating a practical application of serverless technologies in automating code review processes.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Additionally, a <code>webhook</code> workflow was set up to trigger upon receiving webhook events <sup><a href=\"https://github.com/yubrew/ac-outpost/blob/main/.github/workflows/webhook.yml\">3</a></sup>, further integrated with two AWS Lambda functions for dynamic API simulation <code>API-CRON</code> and repository data management <code>Webhook</code>.</p>\n<ul>\n<li><code>API-CRON</code> Which was part of Mock API to randomly simulate the API behavior.</li>\n<li><code>Webhook</code> Which reads data from the DynamoDB and add comment to the PR.</li>\n</ul>\n</li>\n</ul>\n</details>\n<h3 id=\"version-3-feb-12-2024--feb-18-2024\">Version 3 (Feb 12, 2024- Feb 18, 2024)</h3>\n<details>\n<summary>Key Changes in Version 3</summary>\n<p>This phase marked a significant shift in the project’s direction, with the introduction of a GitHub App and Webhook, both hosted on AWS Lambda, showcasing a complex, integrated development environment:</p>\n<ul>\n<li>The flow of that GitHub was as follow:\n<ul>\n<li>The user will install the GitHub App on their repository.</li>\n<li>The GitHub App webhook will be triggered by the GitHub event.</li>\n<li>The GitHub App will send the data to the AWS Lambda.</li>\n<li>The AWS Lambda will process the data, save to the DynamoDB and commit the required file and secrets to the repository.\n<ul>\n<li><code>ai-comment.yml</code> and <code>rust_file_aggregator.sh</code> will be committed to the repository.</li>\n<li>The <code>MOCK API</code> url will be saved to the repository secrets.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>The <code>version 2</code> Lambda was used as it is just updated the following:\n<ul>\n<li>The <code>webhook</code> Lambda updated to update the comment on the PR with the data from the Mock API.</li>\n</ul>\n</li>\n<li>The new Lambda <code>GithubAppWebhook</code> added to handle the GitHub App webhook event.</li>\n</ul>\n</details>\n<h3 id=\"version-4-feb-21-2024--march-01-2024\">Version 4 (Feb 21, 2024- March 01, 2024)</h3>\n<details>\n<summary>Key Changes in Version 4</summary>\n<p>This phase marked a more significant shift in the project’s direction, with the introduction of a GitHub App to manage the <code>PR</code>. Instead of committing the <code>ai-comment.yml</code> and <code>rust_file_aggregator.sh</code> to the repository, the GitHub App will handle the <code>PR</code> and comment on the <code>PR</code> with the data from the Mock API.</p>\n<ul>\n<li>The flow of that GitHub was as follow:\n<ul>\n<li>The app now listens to the <code>PR</code> event and comment on the <code>PR</code> with the data from the Mock API.</li>\n<li>The Github app clone the user repo whenever <code>pr</code> created or syncronized.\n<ul>\n<li>The App perform the required step as previously was hapening on the repo.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>The <code>lambda</code> functions transformed to <code>FastAPI`` and hosted on </code>AWS EC2`.</li>\n</ul>\n</details>\n<h3 id=\"lessons-learned\">Lessons Learned</h3>\n<ul>\n<li>How to create GitHub App and seemelessly integrate webhook with it that hosted on AWS Lambda.</li>\n</ul>";

				const frontmatter = {"title":"GitHub Action & GitHub App","slug":"github-action-and-github-app","startDate":"2024-02-01T00:00:00.000Z","endDate":"2024-02-18T00:00:00.000Z","stacks":["Python","Lambda","DynamoDB","GitHub","GitHub-Action","GitHub-App"],"company":"upwork"};
				const file = "/Users/lablnet/projects/lablnet/lablnet.com/src/content/projects/upwork_github_action_app.md";
				const url = undefined;
				function rawContent() {
					return "\nThis project evolved through several iterations, each marked by specific enhancements and the introduction of new features. Below is a detailed account of these versions, highlighting the key concepts, changes, and technical implementations.\n\n### Version 1 (Feb 1, 2024 - Feb 2, 2024)\n\n<details>\n<summary>Key concepts in Version 1</summary>\n\nIn the initial version, I developed a GitHub Action workflow designed to activate upon every push to the repository and each pull request. The primary objectives were to execute coverage and linter checks for a Rust project, capture these outputs, and automatically comment on the pull request with the results. This workflow was successfully implemented and rigorously tested within the repository. <sup>[1](https://github.com/yubrew/ac-outpost/blob/main/.github/workflows/pr-tasks.yml)</sup>.\n\n</details>\n\n### Version 2 (Feb 4, 2024 - Feb 10, 2024)\n\n<details>\n<summary>Key Changes in Version 2</summary>\n\n- Significant advancements were made in this iteration:\n- A new GitHub Action workflow, `ai-comment.yml`, was created to operate on every push and pull request, enhancing our project's automation and integration capabilities. <sup>[2](https://github.com/yubrew/ac-outpost/blob/main/.github/workflows/ai-audit.yml)</sup>\n\n- A key task was to aggregate all Rust files following a specified schema, excluding any that matched defined patterns ('test', 'schema'). This was achieved through a straightforward shell script, which efficiently processed and prepared these files for further analysis.\n\n  - Note: I am sharing these files because they are on a public repo.\n  - I've done this with a simple shell script below:\n\n      <details>\n      <summary><strong>rust_file_aggregator.sh</strong></summary>\n\n    ```sh\n    #!/bin/bash\n\n    # Initialize the file\n    echo \"\" > rust.md\n\n    # Find all the Rust files in the current directory\n    # and its subdirectories.\n    # and iterate over the files\n    find . -name \"*.rs\" | while read file; do\n        # Check if the file name matches the exclusion patterns\n        # ['test', 'schema']\n        if [[ $file != *test* && $file != *schema* ]]; then\n            # Print the file name\n            echo \"Processing file: $file\"\n            # Append the file name to the output file\n            echo \"### FILE: $(basename $file)\" >> rust.md\n            # Append the file content to the output file\n            cat $file >> rust.md\n        fi\n    done\n    ```\n\n      </details>\n\n  - These files were then transmitted to a mock API endpoint (Which I created), crafted using AWS Lambda and DynamoDB, demonstrating a practical application of serverless technologies in automating code review processes.\n\n- Additionally, a `webhook` workflow was set up to trigger upon receiving webhook events <sup>[3](https://github.com/yubrew/ac-outpost/blob/main/.github/workflows/webhook.yml)</sup>, further integrated with two AWS Lambda functions for dynamic API simulation `API-CRON` and repository data management `Webhook`.\n  - `API-CRON` Which was part of Mock API to randomly simulate the API behavior.\n  - `Webhook` Which reads data from the DynamoDB and add comment to the PR.\n\n</details>\n\n### Version 3 (Feb 12, 2024- Feb 18, 2024)\n\n<details>\n<summary>Key Changes in Version 3</summary>\n\nThis phase marked a significant shift in the project's direction, with the introduction of a GitHub App and Webhook, both hosted on AWS Lambda, showcasing a complex, integrated development environment:\n\n- The flow of that GitHub was as follow:\n  - The user will install the GitHub App on their repository.\n  - The GitHub App webhook will be triggered by the GitHub event.\n  - The GitHub App will send the data to the AWS Lambda.\n  - The AWS Lambda will process the data, save to the DynamoDB and commit the required file and secrets to the repository.\n    - `ai-comment.yml` and `rust_file_aggregator.sh` will be committed to the repository.\n    - The `MOCK API` url will be saved to the repository secrets.\n- The `version 2` Lambda was used as it is just updated the following:\n  - The `webhook` Lambda updated to update the comment on the PR with the data from the Mock API.\n- The new Lambda `GithubAppWebhook` added to handle the GitHub App webhook event.\n\n</details>\n\n### Version 4 (Feb 21, 2024- March 01, 2024)\n\n<details>\n<summary>Key Changes in Version 4</summary>\n\nThis phase marked a more significant shift in the project's direction, with the introduction of a GitHub App to manage the `PR`. Instead of committing the `ai-comment.yml` and `rust_file_aggregator.sh` to the repository, the GitHub App will handle the `PR` and comment on the `PR` with the data from the Mock API.\n\n- The flow of that GitHub was as follow:\n  - The app now listens to the `PR` event and comment on the `PR` with the data from the Mock API.\n  - The Github app clone the user repo whenever `pr` created or syncronized.\n    - The App perform the required step as previously was hapening on the repo.\n- The `lambda` functions transformed to ` FastAPI`` and hosted on  `AWS EC2`.\n\n</details>\n\n### Lessons Learned\n\n- How to create GitHub App and seemelessly integrate webhook with it that hosted on AWS Lambda.\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":3,"slug":"version-1-feb-1-2024---feb-2-2024","text":"Version 1 (Feb 1, 2024 - Feb 2, 2024)"},{"depth":3,"slug":"version-2-feb-4-2024---feb-10-2024","text":"Version 2 (Feb 4, 2024 - Feb 10, 2024)"},{"depth":3,"slug":"version-3-feb-12-2024--feb-18-2024","text":"Version 3 (Feb 12, 2024- Feb 18, 2024)"},{"depth":3,"slug":"version-4-feb-21-2024--march-01-2024","text":"Version 4 (Feb 21, 2024- March 01, 2024)"},{"depth":3,"slug":"lessons-learned","text":"Lessons Learned"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
